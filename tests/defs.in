#!/bin/sh
# defs - Test definitions for cpio.
# @configure_input@

LN_S="@LN_S@"
# SYMLINKS
#   Set SYMLINKS to be "yes" if your system has BSD style symbolic
#   links.  If you don't have symbolic links, set SYMLINKS to be "no"
#   so regress.sh will not try to test symbolic links.
if test "$LN_S" = "ln -s"; then
   SYMLINKS=yes
else
   SYMLINKS=no
fi

# GCPIO
#   Set this to be the name of the version gcpio that is being tested.
#   Allow GCPIO to be set externally.
test -z $GCPIO && GCPIO=`cd ../src && pwd`/cpio


# GNEWC
#   Set this to be the gcpio option for the "new portable" format.
#   This is currently "-H newc", but may change to "-c" in the future.
GNEWC='-H newc'

# GOLDC
#   Set this to be the gcpio option for the "old portable" format.  This
#   is currently "-c", but may change to "-H odc" in the future.
GOLDC='-c'

# BINCPIO
#   If your system has a standard version of cpio, set BINCPIO to be
#   its name so regress.sh can make sure that it and gcpio can
#   read each others' archives.
BINCPIO=@TEST_CPIO@

# BOLDC
#   Set this to be the standard cpio option for the "old portable"
#   format.  This is "-c" on most machines, but "-H odc" on System V.4
#   machines.
BOLDC=@TEST_BOLDC@

# BINTAR
#   If your system has a standard version of tar, set BINTAR to be
#   its name so regress.sh can make sure that gcpio can read standard
#   tar archives.
BINTAR=@TEST_TAR@

# GNUTAR
#   If your system has GNU tar, set GNUTAR to be its name so regress.sh
#   can make sure that gcpio can read POSIX tar archives.
GNUTAR=@TEST_GNUTAR@

# XUID
# UIDNAME
#   Set XUID and UIDNAME to be your uid number and name.
#   On some systems (Linux), "UID" is a readonly variable in sh;
#   that is why we use XUID.
XUID=@TEST_UID@
UIDNAME=@TEST_UIDNAME@

# GID
# GIDNAME
#   Set GID and GIDNAME to be your gid number and name.
GID=@TEST_GID@
GIDNAME=@TEST_GIDNAME@

# GID2
# GID2NAME
#   If your system supports multiple groups and you are a member of
#   more than 1 group, set GID2 and GID2NAME to another group so
#   regress.sh can tests gcpio's ability to set different gid's.
GID2=@TEST_GID2@
GID2NAME=@TEST_GID2NAME@

# DEVFLAG
#   On some machines (eg HP) a flag (eg -x) must be used to get devices
#   to work.  Set to the name of the flag sans "-", eg "x".
DEVFLAG=@TEST_DEVFLAG@

# TEST_MKFIFO
#   Set to the path to mkfifo.  Empty if no such.
MKFIFO=@TEST_MKFIFO@

if test -n "$MKFIFO"; then
   # FIFOS
   #   This is set to "yes" if the system has fifos, including mkfifo.
   FIFOS=yes

   # FIFOCPIO
   #   A version of cpio that can handle fifos.  Empty if no such.
   # FIXME unwarranted assumption.
   FIFOCPIO=$BINCPIO
else
   FIFOS=no
   FIFOCPIO=
fi

#
# Nothing below here is touched directly by configure.
#


# A bunch of programs we use.  "where" must be absolute since the
# tests can change directories.
where=`pwd`
VERIFY=$where/verify
ECHOTIME=$where/echotime
REDIFF=$where/rediff
SWAPB=$where/swapb
SWAPHW=$where/swaphw
WRSPARSE=$where/wrsparse

# ROOT is where testing takes place.  The user can set it if desired.
# Why?  In case the build directory has high-numbered inodes; you
# might want to test it on a less used filesystem to avoid spurious
# failures.
test -z "$ROOT" && ROOT=`pwd`/testSubDir
ACTOUT=$ROOT/actual.out
EXPOUT=$ROOT/expect.out
VEROUT=$ROOT/ver.out
MISSING1=$ROOT/missing1
MISSING2=$ROOT/missing2
# how to sort the output of cpio
SORTOUT="sort +8"

rm -rf $ROOT
mkdir $ROOT
cd $ROOT

# Count of tests and failures.
failed=0
count=0

# FIXME: not all versions of sh have functions.
if [ "$VERBOSE" != "" ]
then
	REPORT ()
	{
	$REDIFF $EXPOUT $ACTOUT > $ROOT/diff.out 2>&1
	count=`expr $count + 1`
	if [ -s $ROOT/diff.out ]
	then
		echo error: "$@"
		echo '  expected output ------  actual output:'
		sed -e 's/^/    /' < $ROOT/diff.out
		echo "FAIL: $@"
		failed=`expr $failed + 1`
		if test -n "$FIRSTFAIL"; then exit 1; fi
	else
		echo "PASS: $@"
	fi
	}

	REPORTV ()
	{
	$REDIFF $EXPOUT $ACTOUT > $ROOT/diff.out 2>&1
	count=`expr $count + 1`
	if [ -s $ROOT/diff.out -o -s $ROOT/ver.out ]
	then
		echo error: "$@"
		echo '  expected output ------  actual output:'
		sed -e 's/^/    /' < $ROOT/diff.out
		echo '  verify output:'
		sed -e 's/^/    /' < $ROOT/ver.out
		echo "FAIL: $@"
		failed=`expr $failed + 1`
		if test -n "$FIRSTFAIL"; then exit 1; fi
	else
		echo "PASS: $@"
	fi
	}

else
	REPORT ()
	{
	$REDIFF $EXPOUT $ACTOUT > $ROOT/diff.out 2>&1
	count=`expr $count + 1`
	if [ -s $ROOT/diff.out ]
	then
		echo "FAIL: $@"
		failed=`expr $failed + 1`
		if test -n "$FIRSTFAIL"; then exit 1; fi
	else
	        echo "PASS: $@"
	fi
	}

	REPORTV ()
	{
	$REDIFF $EXPOUT $ACTOUT > $ROOT/diff.out 2>&1
	count=`expr $count + 1`
	if [ -s $ROOT/diff.out -o -s $ROOT/ver.out ]
	then
		echo "FAIL: $@"
		failed=`expr $failed + 1`
		if test -n "$FIRSTFAIL"; then exit 1; fi
	else
	        echo "PASS: $@"
	fi
	}

fi

echo1 ()
{
	for i in $*
	do
		echo $i
	done
}

rm -rf src1 src2 src3 src4 dst1 dst2 dst2swap dst3 dst4
mkdir src1
cd src1
echo foz > foo
$WRSPARSE  # FIXME only for sparse tests
mkdir tmp tmp2 tmp3 dev
echo baz > bar

if test "$FIFOS" = yes; then
   mkfifo pipe
   ln pipe copy
   mkfifo diff
   mkfifo dev/pipe2
   cat << 'ENDIT' > $MISSING1
./dev/pipe2
./pipe
./copy
./diff
ENDIT
   cat << 'ENDIT' > $MISSING2
../src1/./dev/pipe2: missing file.
./copy: missing file.
./diff: missing file.
./pipe: missing file.
ENDIT
else
   : > $MISSING1
   : > $MISSING2
fi

cd tmp
echo hello1 > hello
if [ "$SYMLINKS" = "yes" ]
then
   $LN_S hello hello2
fi
ln hello hello3
echo the world > world
cd ../tmp2
if [ "$SYMLINKS" = "yes" ]
then
   $LN_S ../foo foolink
fi
cd ../tmp3
mkdir tmp4
cd ..
find . -depth -print > ../1.find

# Create a destination directory
cd $ROOT
mkdir dst1
