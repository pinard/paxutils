This is Info file paxutils.info, produced by Makeinfo version 1.68 from
the input file paxutils.texi.

START-INFO-DIR-ENTRY
* pax utilities: (paxutils).	pax and other archiving utilities.
* cpio: (paxutils)cpio invocation.		Handling cpio archives.
* pax: (paxutils)pax invocation.		The POSIX archiver.
* tar: (paxutils)tar invocation.		Making tape (or disk) archives.
* mt: (paxutils)mt invocation.			Basic tape positioning.
* rmt: (paxutils)rmt invocation.		The remote tape facility.
END-INFO-DIR-ENTRY

   This file documents `paxutils' 2.4h.

   Copyright (C) 1992, 1994, 1995, 1996, 1997, 1998 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: paxutils.info,  Node: blocking-factor,  Next: record-size,  Prev: Blocks and records,  Up: Blocking

Setting the blocking factor
---------------------------

   In a standard `tar' file (no options), the block size is 512 bytes
and the record size is 10240 bytes, for a blocking factor of 20.  In
fact, the default blocking factor is set when `tar' is compiled, and is
typically 20.  The output of `tar --help', near the end, shows the
default blocking factor which was compiled in the `tar' version you are
using.  Archives with blocking factors larger than 20 cannot be read by
very old versions of `tar', or by some newer versions of `tar' running
on old machines with small address spaces.  With this `tar', the
blocking factor of an archive is limited only by the maximum record
size of the device containing the archive, or by the amount of available
virtual memory.

   What the `--blocking-factor=BLOCKS' (`-b BLOCKS') option does is to
set the blocking factor, that is, to change the record size while
leaving the block size at 512 bytes.  A blocking factor of 20 was fine
for ancient 800 or 1600 bpi reel-to-reel tape drives; most tape drives
these days prefer much bigger records in order to stream and not waste
tape.  When writing tapes, some tend to use a factor of the order of
2048, say, giving a record size of around one megabyte.  This is
acceptable nowadays, as the tape technology is now much more dependable
that it once was, and errors are much less likely to occur.

   When reading an archive, `tar' can usually figure out the record
size itself.  To get it to do this, you can use
`--blocking-factor=BLOCKS' (`-b BLOCKS') to specify a blocking factor
larger than real one, and `tar' will diagnose the observed record size
as shorter than expected.  In this indirect way, you can use `tar' to
learn about the actual record size of the first record on a tape!  The
diagnostic is not produced when the observed record size matches the
expected size.

   Further complicating the problem is that some tape drives ignore the
blocking entirely.  For these, `tar' cannot easily determine the real
block size.  In such cases, specifying a larger record size in `tar'
can still improve performance a tiny bit, yet most of the improvement
has already been provided by the tape system itself.

   If you use a non-default blocking factor when you create an archive,
you must specify the same blocking factor when you modify that archive.
Some archive devices will also require you to specify the blocking
factor when reading that archive; however, this is not typically the
case.  Usually, you can use `--list' (`-t') without specifying a
blocking factor--`tar' reports a non-default record size and then lists
the archive members as it would normally.  To extract files from an
archive with a non-standard blocking factor (particularly if you're not
sure what the blocking factor is), you can usually use the
`--read-full-records' (`-B') option while specifying a blocking factor
larger then the blocking factor of the archive (for example, `tar
--extract --read-full-records --blocking-factor=300').  *Note list::,
for more information on the `--list' (`-t') subcommand.  *Note
Reading::, for a more detailed explanation of that option.

   If the archive is in a disk file or a pipe, some might sometimes
want to specify a smaller blocking factor, since a large one will
result in more `NUL' bytes at the end of the archive, but it might not
be worth it.  Beware that for the `tar' blocking to be effective, `tar'
should directly write to the device.  Blocking is effectively defeated
or overridden when a pipe interposes another step between `tar' and the
device (like a call to `dd', for instance).


File: paxutils.info,  Node: record-size,  Next: Media types,  Prev: blocking-factor,  Up: Blocking

Setting a record size
---------------------

   The `--record-size=SIZE' option instructs `tar' to use SIZE bytes
per record when accessing the archive.  The value of SIZE should be
evenly divisible by 512.  This option is an alternative to using
`--blocking-factor=BLOCKS' (`-b BLOCKS'), except that the unit for
`--record-size=SIZE' is a single byte, while the unit for
`--blocking-factor=BLOCKS' (`-b BLOCKS') is a whole `tar' block.  *Note
blocking-factor::.


File: paxutils.info,  Node: Media types,  Next: Reblocking,  Prev: record-size,  Up: Blocking

Per-Media blocking considerations
---------------------------------

   When handling various tapes or cartridges, you have to take care of
selecting a proper blocking, that is, the number of disk blocks you put
together as a single record on the tape, without intervening tape gaps.
Strangely, on more than a few systems, the mere fact of not using an
adequate blocking factor yields rather unexpected or cryptic
diagnostics, like:

     Cannot write to /dev/dlt: Invalid argument

So, one might have to pay attention to the requirements of device
drivers.  To make things a bit confusing, it also happens that the
`tar' bundled by the system is aware of record size idiosyncrasies,
while `tar' requires an explicit specification for the record size,
which it cannot guess.  This yields some people to believe that `tar'
is misbehaving, because by comparison, `the bundled `tar' works OK'.
Merely using something like `-b 256', say, might resolve the problem.

   `tar' uses a blocking factor of 20 by default for historical
reasons, and it does not really matter when reading or writing to disk.
Current tape technology would easily accomodate higher blockings.  Sun
recommends a blocking of 126 for Exabytes and 96 for DATs.  Another
source said that Exabyte drives have a physical block size of 8KB, and
that using `-b 112' solved their problems.  We were told that for some
DLT drives, the blocking should be a multiple of 4KB, preferably 64KB
(`-b 128' or `256'), for decent performance.  Other manufacturers may
use different recommendations for the same tapes.  This might also
depend of the buffering techniques used by modern tape controllers.
Some impose a minimum blocking, or a maximum blocking.  Others request
blocking to be some power of two.

   So there is no fixed rule for blocking.  But blocking at read time
should ideally be the same as blocking used at write time.  At one
place we know, with a wide variety of equipment, they found it best to
use a blocking of 32 to guarantee that their tapes are fully
interchangeable between all systems they have.

   We were also told that, for recycled tapes, prior erasure (by the
exact drive unit that will be used to create the archives) sometimes
lowers the error rates observed at rewriting time.


File: paxutils.info,  Node: Reblocking,  Prev: Media types,  Up: Blocking

Automatic reblocking
--------------------

   When handling compressed archives, `tar' automatically unblocks the
archives before decompression occurs, or reblocks created archives just
after compression, as needed.(1)

   When older `gzip' programs are directly given such reblocked
compressed archives, they may complain like this:

     $ tar cfz - FILE | gzip -t
     gzip: stdin: decompression OK, trailing garbage ignored

Because of the reblocking, there may be extraneous zero blocks after the
`gzip' output, which older versions of `gzip' diagnose as garbage.
Jean-loup and I agreed, to handle this particular case, that newer
versions of `gzip' would be more tolerant to strings of zeros, and just
ignore them.  So, diagnostics like above will progressively disappear,
as various older `gzip' binaries get replaced.  In any case, they are
innocuous.

   As a special case, if a compressed archive is directly created on a
local disk, and not through stdout, and if the blocking factor is not
explicitly specified by the user, then the produced file will not be
reblocked, and so, might appear as if the last record has not been
padded to full length.  In all other cases, reblocking occurs.

   ---------- Footnotes ----------

   (1) Prior to `tar' 1.12, unblocking or reblocking did not occur
unless the `--compress-block' option (or even older:
`--block-compress') was given.  Such options are now obsolete.


File: paxutils.info,  Node: Many on one,  Next: One on many,  Prev: Blocking,  Up: Media

Many archives on one tape
=========================

   Most tape devices have two entries in the `/dev' directory, or
entries that come in pairs, which differ only in the minor number for
this device.  Let's take for example `/dev/tape', which often points to
the only or usual tape device of a given system.  There might be a
corresponding `/dev/nrtape' or `/dev/ntape'.  The simpler name is the
*rewinding* version of the device, while the name having `nr' in it is
the *no rewinding* version of the same device.

   A rewinding tape device will bring the tape back to its beginning
point automatically when this device is opened or closed.  Since `tar'
opens the archive file before using it and closes it afterwards, this
means that a simple

     $ tar cf /dev/tape DIRECTORY

will reposition the tape to its beginning both before and after saving
the DIRECTORY contents to it, thus erasing the prior tape contents and
making it so that any subsequent write subcommand will destroy what has
just been saved.

   So, a rewinding device is normally meant to hold one and only one
file.  If you want to put more than one `tar' archive on a given tape,
you will need to avoid using the rewinding version of the tape device.
You will also have to pay special attention to tape positioning.
Errors in positioning may overwrite the valuable data already on your
tape.  Many people, burned by past experiences, will only use rewinding
devices and limit themselves to one file per tape, precisely to avoid
the risk of such errors.  Be fully aware that writing at the wrong
position on a tape loses all information past this point and most
probably until the end of the tape, and this destroyed information
*cannot* be easily recovered, if indeed it can ever be recovered at all.

   To save DIRECTORY-1 as a first archive at the beginning of a tape,
and leave that tape ready for a second archive, you should use the
*non-rewinding* tape device:

     $ mt -f /dev/nrtape rewind
     $ tar cf /dev/nrtape DIRECTORY-1

   "Tape marks" are special magnetic patterns written on the tape media,
which are later recognizable by the reading hardware.  Tape marks
consume a *lot* more space on the tape than a usual gap, and the tape
drive hardware is often able to detect them even while winding the tape
at higher speed.

   These marks are used after each file, when there are many on a
single tape.  An empty file (that is to say, two tape marks in a row)
signals the logical end of the tape, after which no files exist.
Clever non-rewinding tape device drivers react to the close request
issued by `tar' by first writing two tape marks after your archive, and
by backspacing over one of these.  So, if you remove the tape at that
time from the tape drive, it is properly terminated.  But if you write
another file at the current position, the second tape mark gets erased
by the new information, leaving only one tape mark between files.

   So, you may now save DIRECTORY-2 as a second archive after the first
on the same non-rewinding tape by issuing the command:

     $ tar cf /dev/nrtape DIRECTORY-2

and so on for all the archives you want to put on the same tape.

   Another usual case is that you do not write all the archives the same
day, and you need to remove and store the tape between two archive
sessions.  In general, you must remember how many files are already
saved on your tape.  Suppose your tape already has 16 files on it, and
you are ready to write the 17th.  You have to take care to skip the
first 16 tape marks before saving DIRECTORY-17, say, by using these
commands:

     $ mt -f /dev/nrtape rewind
     $ mt -f /dev/nrtape fsf 16
     $ tar cf /dev/nrtape DIRECTORY-17

   In all the previous examples, we put aside blocking considerations,
but you should do the proper things for that as well.  *Note Blocking::.

* Menu:

* Tape positioning::            Tape positions and tape marks
* mt invocation::               The `mt' utility


File: paxutils.info,  Node: Tape positioning,  Next: mt invocation,  Prev: Many on one,  Up: Many on one

Tape positions and tape marks
-----------------------------

   Just as archives can store more than one file from the file system,
tapes can store more than one archive file.  To keep track of where
archive files (or any other type of file stored on tape) begin and end,
tape archive devices write magnetic "tape marks" on the archive media.
Tape drives write one tape mark between files, two at the end of all
the file entries.

   If you think of data as a series of records "RRRR", and tape marks as
"*", a tape might look like the following:

     RRRR*RRRRRR*RRRRR*RR*RRRRR**-------------------------

   Tape devices read and write tapes using a read/write "tape head"--a
physical part of the device which can only access one point on the tape
at a time.  When you use `tar' to read or write archive data from a
tape device, the device will begin reading or writing from wherever on
the tape the tape head happens to be, regardless of which archive or
what part of the archive the tape head is on.  Before writing an
archive, you should make sure that no data on the tape will be
overwritten (unless it is no longer needed).  Before reading an
archive, you should make sure the tape head is at the beginning of the
archive you want to read.  (The `restore' script will find the archive
automatically.   *Note Scripted restoration::.)  *Note mt invocation::,
for an explanation of the tape moving utility.

   If you want to add new archive file entries to a tape, you should
advance the tape to the end of the existing file entries, backspace
over the last tape mark, and write the new archive file.  If you were
to add two archives to the example above, the tape might look like the
following:

     RRRR*RRRRRR*RRRRR*RR*RRRRR*RRR*RRRR**----------------


File: paxutils.info,  Node: mt invocation,  Prev: Tape positioning,  Up: Many on one

The `mt' utility
----------------

   *Note blocking-factor::.

   You can use the `mt' utility to advance or rewind a tape past a
specified number of archive files on the tape.  This will allow you to
move to the beginning of an archive before extracting or reading it, or
to the end of all the archives before writing a new one.

   The syntax of the `mt' command is:

     $ mt [-f TAPENAME] OPERATION [NUMBER]

   where TAPENAME is the name of the tape device, NUMBER is the number
of times a subcommand is performed (with a default of one), and
OPERATION is one of the following:

`eof'
`weof'
     Writes NUMBER tape marks at the current position on the tape.

`fsf'
     Moves tape position forward NUMBER files.

`bsf'
     Moves tape position back NUMBER files.

`rewind'
     Rewinds the tape.  (Ignores NUMBER).

`offline'
`rewoff1'
     Rewinds the tape and takes the tape device off-line. (Ignores
     NUMBER).

`status'
     Prints status information about the tape unit.

   If you don't specify a TAPENAME, `mt' uses the environment variable
`TAPE'; if `TAPE' is not defined, `mt' uses the device `/dev/rmt12'.

   `mt' returns a 0 exit status when the operation(s) were successful,
1 if the command was unrecognized, and 2 if a subcommand failed.

   If you use `--extract' (`--get', `-x') with the
`--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option specified, `tar'
will read an archive label (the tape head has to be positioned on it)
and print an error if the archive label doesn't match the ARCHIVE-NAME
specified.  ARCHIVE-NAME can be any regular expression.  If the labels
match, `tar' extracts the archive.  *Note label::, .  `tar --list
--label' will cause `tar' to print the label.


File: paxutils.info,  Node: One on many,  Next: Being careful,  Prev: Many on one,  Up: Media

Using multiple tapes
====================

   Often you might want to write a large archive, one larger than will
fit on the actual tape you are using.  In such a case, you can run
multiple `tar' commands, but this can be inconvenient, particularly if
you are using options like `--exclude=PATTERN' or dumping entire
filesystems.  Therefore, `tar' supports multiple tapes automatically.

   Use `--multi-volume' (`-M') on the command line, and then `tar' will,
when it reaches the end of the tape, prompt for another tape, and
continue the archive.  Each tape will have an independent archive, and
can be read without needing the other.  (As an exception to this, the
file that `tar' was archiving when it ran out of tape will usually be
split between the two archives; in this case you need to extract from
the first archive, using `--multi-volume' (`-M'), and then put in the
second tape when prompted, so `tar' can restore both halves of the
file.)

   `tar' multi-volume archives do not use a truly portable format.  You
need `tar' at both ends to process them properly.

   When prompting for a new tape, `tar' accepts any of the following
responses:

`?'
     Request `tar' to explain possible responses.

`q'
     Request `tar' to exit immediately.

`n FILENAME'
     Request `tar' to write the next volume on the file FILENAME.

`!'
     Request `tar' to run a subshell.

`y'
     Request `tar' to begin writing the next volume.

   (You should type `y' only *after* you have changed the tape;
otherwise `tar' will write over the volume it just finished.)

   If you want more elaborate behavior than this, give `tar' the
`--info-script=SCRIPT-NAME' (`--new-volume-script=SCRIPT-NAME', `-F
SCRIPT-NAME') option.  The file SCRIPT-NAME is expected to be a program
(or shell script) to be run instead of the normal prompting procedure.
When the program finishes, `tar' will immediately begin writing the
next volume.  The behavior of the `n' response to the normal
tape-change prompt is not available if you use
`--info-script=SCRIPT-NAME' (`--new-volume-script=SCRIPT-NAME', `-F
SCRIPT-NAME').

   The method `tar' uses to detect end of tape is not perfect, and
fails on some operating systems or on some devices.  You can use the
`--tape-length=KBYTES' (`-L KBYTES') option if `tar' can't detect the
end of the tape itself.  This option selects `--multi-volume' (`-M')
automatically.  The SIZE argument should then be the usable size of the
tape.  But for many devices, and floppy disks in particular, this
option is never actually required, as far as we know.

   If you want `tar' to cycle through a series of tape drives, then you
can use the `n' response to the tape-change prompt.  This is error
prone, however, and doesn't work at all with
`--info-script=SCRIPT-NAME' (`--new-volume-script=SCRIPT-NAME', `-F
SCRIPT-NAME').  Therefore, if you give `tar' multiple
`--file=ARCHIVE-NAME' (`-f ARCHIVE-NAME') options, then the specified
files will be used, in sequence, as the successive volumes of the
archive.  Only when the first one in the sequence needs to be used
again will `tar' prompt for a tape change (or run the info script).

   Multi-volume archives

   With `--multi-volume' (`-M'), `tar' will not abort when it cannot
read or write any more data.  Instead, it will ask you to prepare a new
volume.  If the archive is on a magnetic tape, you should change tapes
now; if the archive is on a floppy disk, you should change disks, and so
forth.

   Each volume of a multi-volume archive is an independent `tar'
archive, complete in itself.  For example, you can list or extract any
volume alone; just don't specify `--multi-volume' (`-M').  However, if
one file in the archive is split across volumes, the only way to extract
it successfully is with a multi-volume extract command `--extract
--multi-volume' (`-xM') starting on or before the volume where the file
begins.

   For example, let's presume someone has two tape drives on a system,
named `/dev/tape0' and `/dev/tape1'.  To have `tar' switch to the
second drive when it needs to write the second tape, and then back to
the first tape, and so forth, just do either of:

     $ tar --create --multi-volume --file=/dev/tape0 --file=/dev/tape1 FILES
     $ tar cMff /dev/tape0 /dev/tape1 FILES

* Menu:

* Multi-volume archives::       Archives longer than one tape or disk
* multi-volume::                Using multi-volume mode
* tape-length::                 Announcing the tape length
* info-script::                 Taking actions at volume switching
* volno-file::                  Changing the volume number in prompts


File: paxutils.info,  Node: Multi-volume archives,  Next: multi-volume,  Prev: One on many,  Up: One on many

Archives longer than one tape or disk
-------------------------------------

   To create an archive that is larger than will fit on a single unit of
the media, use the `--multi-volume' (`-M') option in conjunction with
the `--create' (`-c') option (*note create::.).  A "multi-volume"
archive can be manipulated like any other archive (provided the
`--multi-volume' (`-M') option is specified), but is stored on more
than one tape or disk.

   When you specify `--multi-volume' (`-M'), `tar' does not report an
error when it comes to the end of an archive volume (when reading) or
the end of the media (when writing).  Instead, it prompts you to load a
new storage volume.  If the archive is on a magnetic tape, you should
change tapes when you see the prompt; if the archive is on a floppy
disk, you should change disks; and so forth.

   You can read each individual volume of a multi-volume archive as if
it were an archive by itself.  For example, to list the contents of one
volume, use `--list' (`-t'), without `--multi-volume' (`-M') specified.
To extract an archive member from one volume (assuming it is on that
volume), use `--extract' (`--get', `-x'), again without
`--multi-volume' (`-M').

   If an archive member is split across volumes (that is, its entry
begins on one volume of the media and ends on another), you need to
specify `--multi-volume' (`-M') to extract it successfully.  In this
case, you should load the volume where the archive member starts, and
use `tar --extract --multi-volume'--`tar' will prompt for later volumes
as it needs them.  *Note Extracting archives::, for more information
about extracting archives.

   `--info-script=SCRIPT-NAME' (`--new-volume-script=SCRIPT-NAME', `-F
SCRIPT-NAME') is like `--multi-volume' (`-M'), except that `tar' does
not prompt you directly to change media volumes when a volume is
full--instead, `tar' runs commands you have stored in SCRIPT-NAME.  For
example, this option can be used to eject cassettes, or to broadcast
messages such as `Someone please come change my tape' when performing
unattended backups.  When SCRIPT-NAME is done, `tar' will assume that
the media has been changed.

   Multi-volume archives can be modified like any other archive.  To add
files to a multi-volume archive, you need to only mount the last volume
of the archive media (and new volumes, if needed).  For all other
subcommands that modify the archive, you need to use the entire archive.

   If a multi-volume archive was labeled using `--label=ARCHIVE-LABEL'
(`-V ARCHIVE-LABEL') (*note label::.) when it was created, `tar' will
not automatically label volumes which are added later.  To label
subsequent volumes, specify `--label=ARCHIVE-LABEL' (`-V
ARCHIVE-LABEL') again in conjunction with the `--append' (`-r'),
`--update' (`-u') or `--concatenate' (`--catenate', `-A') subcommand.


File: paxutils.info,  Node: multi-volume,  Next: tape-length,  Prev: Multi-volume archives,  Up: One on many

Using multi-volume mode
-----------------------

   When the `--multi-volume' (`-M') option is given, `tar' creates a
multi-volume archive, when used in conjunction with `--create' (`-c').
To perform any other subcommand on a multi-volume archive, specify
`--multi-volume' (`-M') in conjunction with that subcommand.  It
creates, lists, or extracts a multi-volume archive.

   This option causes `tar' to write a "multi-volume" archive--one that
may be larger than will fit on the medium used to hold it.  *Note
Multi-volume archives::.

   Beware that there is *no* real standard about the proper way for a
`tar' archive to span volume boundaries.  If you have a multi-volume
created by some vendor's `tar', there is almost no chance you could
read all the volumes with `tar'.  The converse is also true: you should
not expect multi-volume archives created by `tar' to be fully recovered
by any vendor's `tar'.  Since there is little chance that, in mixed
system configurations, some vendor's `tar' will work on another
vendor's machine, and there is a great chance that `tar' will work on
most of them, your best bet is to install `tar' on all machines between
which you know exchange of files is possible.


File: paxutils.info,  Node: tape-length,  Next: info-script,  Prev: multi-volume,  Up: One on many

Announcing the tape length
--------------------------

   Option `--tape-length=KBYTES' (`-L KBYTES') has the effect of
forcing a change of the tape after writing NUM x 1024 bytes.

   This option might be useful when your tape drivers do not properly
detect the end of physical tapes.  By being slightly conservative on the
maximum tape length, you might avoid the problem entirely.


File: paxutils.info,  Node: info-script,  Next: volno-file,  Prev: tape-length,  Up: One on many

Taking actions at volume switching
----------------------------------

   The `--info-script=SCRIPT-NAME' (`--new-volume-script=SCRIPT-NAME',
`-F SCRIPT-NAME') option indicates the name of a program, or shell
script, meant to help create a multi-volume archive via a script.  Used
in conjunction with `--create' (`-c').  It gets `file' executed at end
of each tape.  This implies `--multi-volume' (`-M').

   This script should exit with zero status if `tar' is to continue the
archiving operation.  `tar' interprets a non-zero exit (or any other
kind of error) as a request to abort processing right away.  For
example, this could ease the termination of `tar' when the script
determines it runs out of tapes, or in other situations of unattented
environments.


File: paxutils.info,  Node: volno-file,  Prev: info-script,  Up: One on many

Changing the volume number in prompts
-------------------------------------

   The volume number used by `tar' in its tape-change prompt can be
changed; if you give the `--volno-file=FILE-OF-NUMBER' option, then
FILE-OF-NUMBER should be a nonexistent file to be created, or a file
already containing a decimal number.  That number will be used as the
volume number of the first volume written.  When `tar' is finished, it
will rewrite the file with the now-current volume number.  (This does
not change the volume number written on a tape label, as per *Note
label::; it *only* affects the number used in the prompt.)


File: paxutils.info,  Node: Being careful,  Next: Other tape considerations,  Prev: One on many,  Up: Media

Being even more careful
=======================

* Menu:

* label::                       Including labels in the archive
* verify::                      Verifying data as it is stored
* Write protection::            Write protection


File: paxutils.info,  Node: label,  Next: verify,  Prev: Being careful,  Up: Being careful

Including labels in the archive
-------------------------------

   To give the archive a name which will be recorded in it, use the
`--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option.  This will write a
special block identifying VOLUME-LABEL as the name of the archive to
the front of the archive, which will be displayed when the archive is
listed with `--list' (`-t').  If you are creating a multi-volume
archive with `--multi-volume' (`-M') (*note One on many::.), then the
volume label will have `Volume NNN' appended to the name you give,
where NNN is the number of the volume of the archive.  If you use the
`--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option when reading an
archive, it checks to make sure the label on the tape matches the one
you give.  *Note label::.

   When `tar' writes an archive to tape, it creates a single tape file.
If multiple archives are written to the same tape, one after the other,
they each get written as separate tape files.  When extracting, it is
necessary to position the tape at the right place before running `tar'.
To do this, use the `mt' command.  For more information on the `mt'
command and on the organization of tapes into a sequence of tape files,
see *Note mt invocation::.

   People often seem to do:

     $ tar --label="SOME-PREFIX `date +SOME-FORMAT`"

or such, to put a common date on all volumes or an archive set.

   The `--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option creates an
archive with volume name NAME.

   This option causes `tar' to write out a "volume header" at the
beginning of the archive.  If `--multi-volume' (`-M') is used, each
volume of the archive will have a volume header of `NAME Volume N',
where N is 1 for the first volume, 2 for the next, and so on.

   To avoid problems caused by misplaced paper labels on the archive
media, you can include a "label" entry--an archive member which contains
the name of the archive--in the archive itself.  Use the
`--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option in conjunction with
the `--create' (`-c') subcommand to include a label entry in the
archive as it is being created.

   If you create an archive using both `--label=ARCHIVE-LABEL' (`-V
ARCHIVE-LABEL') and `--multi-volume' (`-M'), each volume of the archive
will have an archive label of the form `ARCHIVE-LABEL Volume N', where
N is 1 for the first volume, 2 for the next, and so on.  *Note
Multi-volume archives::, for information on creating multiple volume
archives.

   If you list or extract an archive using `--label=ARCHIVE-LABEL' (`-V
ARCHIVE-LABEL'), `tar' will print an error if the archive label doesn't
match the ARCHIVE-LABEL specified, and will then not list nor extract
the archive.  In those cases, the ARCHIVE-LABEL argument is interpreted
as a globbing-style pattern which must match the actual magnetic volume
label.  *Note Wildcards::, for a precise description of how the match
is attempted.(1) If the switch `--multi-volume' (`-M') is being used,
the volume label matcher will also suffix ARCHIVE-LABEL by
` Volume [1-9]*' if the initial match fails, before giving up.  Since
the volume numbering is automatically added in labels at creation time,
it sounded logical to help the user take care of it when the archive is
being read as well.

   The `--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option was once
called `--volume', but is not available under that name anymore.

   To find out an archive's label entry (or to find out if an archive
has a label at all), use `tar --list --verbose'.  `tar' will print the
label first, and then print archive member information, as in the
example below:

     $ tar --verbose --list --file=iamanarchive
     V--------- 0 0 0 1992-03-07 12:01 iamalabel--Volume Header--
     -rw-rw-rw- myself users 40 1990-05-21 13:30 iamafilename

   The `--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option includes an
"archive-label" at the beginning of the archive when the archive is
being created, when used in conjunction with the `--create' (`-c')
option.  Check to make sure the archive label matches the one specified
(when used in conjunction with the `--extract' (`--get', `-x') option).

   To get a common label on all tapes of a series, use the
`--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option.  To ensure that
this label is different in each series created through a single script
used on a regular basis, just manage to get a date string as part of
the label.  For example:

     $ tar cfMV /dev/tape "Daily backup for `date +%Y-%m-%d`"
     $ tar --create --file=/dev/tape --multi-volume \
          --label="Daily backup for `date +%Y-%m-%d`"

   Also note that each label has its own date and time, which
corresponds to when `tar' initially attempted to write it, often soon
after the operator launches `tar' or types the carriage return telling
that the next tape is ready.  Comparing date labels gives an idea of
tape throughput only if the delays for rewinding tapes and the operator
switching them were negligible, which is usually not the case.

   ---------- Footnotes ----------

   (1) Previous versions of `tar' used full regular expression
matching, or before that, only exact string matching, instead of
wildcard matching.  We decided for the sake of simplicity to use a
uniform matching device throughout `tar'.


File: paxutils.info,  Node: verify,  Next: Write protection,  Prev: label,  Up: Being careful

Verifying data as it is stored
------------------------------

   Option `--verify' (`-W') attempts to verify the archive after
writing.

   This option causes `tar' to verify the archive after writing it.
Each volume is checked after it is written, and any discrepancies are
recorded on the standard error output.

   Verification requires that the archive be on a backspaceable medium.
This means that pipes, some cartridge tape drives, and some other
devices cannot be verified.

   You can ensure the accuracy of an archive by comparing files in the
filesystem with archive members.  `tar' can compare an archive to the
filesystem as the archive is being written, to verify a write
operation, or can compare a previously written archive, to ensure that
it is up to date.

   To check for discrepancies in an archive immediately after it is
written, use the `--verify' (`-W') option in conjunction with the
`--create' (`-c') subcommand.  When this option is specified, `tar'
checks archive members against their counterparts in the file system,
and reports discrepancies on the standard error.  In multi-volume
archives, each volume is verified after it is written, before the next
volume is written.

   To verify an archive, you must be able to read it from before the end
of the last written entry.  This option is useful for detecting data
errors on some tapes.  Archives written to pipes, some cartridge tape
drives, and some other devices cannot be verified.

   One can explicitly compare an already made archive with the file
system by using the `--compare' (`--diff', `-d') option, instead of
using the more automatic `--verify' (`-W') option.  *Note compare::.

   Note that these two options have a slightly different intent.  The
`--compare' (`--diff', `-d') option checks how similar are the logical
contents of some archive to what is on your disks, while the `--verify'
(`-W') option is really for checking if the physical contents agree and
if the recording media itself is of dependable quality.  So, for the
`--verify' (`-W') option, `tar' tries to defeat all in-memory cache
pertaining to the archive, while it leaves the speed optimization
undisturbed for the `--compare' (`--diff', `-d') option.  If you
nevertheless use `--compare' (`--diff', `-d') for media verification,
you may have to defeat the in-memory cache yourself, maybe by opening
and reclosing the door latch of your recording unit, forcing some doubt
in your operating system about the fact this is really the same volume
as the one just written or read.

   The `--verify' (`-W') option would not be necessary if drivers were
indeed able to detect dependably all write failures.  This sometimes
requires many magnetic heads, some able to read after the writes
occurred.  One would not say that drivers unable to detect all cases
are necessarily flawed, as far as programming is concerned.


File: paxutils.info,  Node: Write protection,  Prev: verify,  Up: Being careful

Write protection
----------------

   Almost all tapes and diskettes, and in a few rare cases even disks,
can be "write protected", to protect data on them from being changed.
Once an archive is written, you should write protect the media to
prevent the archive from being accidently overwritten or deleted.
(This will protect the archive from being changed with a tape or floppy
drive--it will not protect it from magnetic fields or other physical
hazards).

   The write protection device itself is usually an integral part of the
physical media, and can be a two position (write enabled/write
disabled) switch, a notch which can be popped out or covered, a ring
which can be removed from the center of a tape reel, or some other
changeable feature.


File: paxutils.info,  Node: Other tape considerations,  Prev: Being careful,  Up: Media

Other tape considerations
=========================

   Some versions of Unix (Ultrix 3.1 is known to have this problem),
can claim that a short write near the end of a tape succeeded, when it
actually failed.  This will result in the -M option not working
correctly.  The best workaround at the moment is to use a significantly
larger blocking factor than the default 20.

   In order to update an archive, `tar' must be able to backspace the
archive in order to reread or rewrite a record that was just read (or
written).  This is currently possible only on two kinds of files: normal
disk files (or any other file that can be backspaced with `lseek'), and
industry-standard 9-track magnetic tape (or any other kind of tape that
can be backspaced with the `MTIOCTOP' `ioctl').

   This means that the `--append' (`-r'), `--update' (`-u'),
`--concatenate' (`--catenate', `-A'), and `--delete' commands will not
work on any other kind of file.  Some media simply cannot be
backspaced, which means that these commands and options will never be
able to work on them.  These non-backspacing media include pipes and
cartridge tape drives.

   Some other media can be backspaced, and `tar' will work on them once
`tar' is modified to do so.

   Archives created with the `--multi-volume' (`-M'),
`--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL'), and `--incremental'
(`-G') options may not be readable by other versions of `tar'.  In
particular, restoring a file that was split over a volume boundary will
require some careful work with `dd', if it can be done at all.  Other
versions of `tar' may also create an empty file whose name is that of
the volume header.  Some versions of `tar' may create normal files
instead of directories archived with the `--incremental' (`-G') option.

errors from system:
permission denied
no such file or directory
not owner

errors from `tar':
directory checksum error
header format error

errors from media/system:
i/o error
device busy


File: paxutils.info,  Node: Backups,  Next: All options,  Prev: Media,  Up: Top

Performing backups and restoring files
**************************************

   `tar' is distributed along with the scripts which the Free Software
Foundation uses for performing backups.  There are no corresponding
scripts available yet for doing restoration of files.  Even though
there is a good chance those scripts may be satisfactory to you, they
are not the only scripts or methods available for doing backups and
restores.  You may well create your own, or use more sophisticated
packages dedicated to that purpose.

   Some users are enthusiastic about `Amanda' (The Advanced Maryland
Automatic Network Disk Archiver), a backup system developed by James da
Silva (<jds@cs.umd.edu>) and available on many Unix systems.  This is
free software, and it is available at these places:

     http://www.cs.umd.edu/projects/amanda/amanda.html
     ftp://ftp.cs.umd.edu/pub/amanda

   Here is a possible plan for a future documentation about the backup
scripts which are provided within the `tar' distribution.

.* dumps
. + what are dumps

. + different levels of dumps
.  - full dump = dump everything
.  - level 1, level 2 dumps etc, -
	A level n dump dumps everything changed since the last level
	n-1 dump (?)

. + how to use scripts for dumps  (ie, the concept)
.  - scripts to run after editing backup specs (details)

. + Backup Specs, what is it.
.  - how to customize
.  - actual text of script  [/sp/dump/backup-specs]

. + Problems
.  - rsh doesn't work
.  - rtape isn't installed
.  - (others?)

. + the --incremental option of tar

. + tapes
.  - write protection
.  - types of media
.   : different sizes and types, useful for different things
.  - files and tape marks
     one tape mark between files, two at end.
.  - positioning the tape
     MT writes two at end of write,
       backspaces over one when writing again.

   This chapter documents both the provided FSF scripts and the `tar'
options which are more specific to use as a backup tool.

   To "back up" a file system means to create archives that contain all
the files in that file system.  Those archives can then be used to
restore any or all of those files (for instance if a disk crashes or a
file is accidently deleted).  File system "backups" are also called
"dumps".

* Menu:

* incremental listed-incremental::  The incremental options
* Backup levels::               Levels of backups
* Backup parameters::           Setting parameters for backups and restoration
* Scripted backups::            Using the backup scripts
* Scripted restoration::        Using the restore script


File: paxutils.info,  Node: incremental listed-incremental,  Next: Backup levels,  Prev: Backups,  Up: Backups

The incremental options
=======================

* Menu:

* incremental::                 Backing up without a snapshot list
* listed-incremental::          Backing up with a snapshot list


File: paxutils.info,  Node: incremental,  Next: listed-incremental,  Prev: incremental listed-incremental,  Up: incremental listed-incremental

Backing up without a snapshot list
----------------------------------

   `--incremental' (`-G') is used in conjunction with `--create' (`-c'),
`--extract' (`--get', `-x'), or `--list' (`-t') when backing up and
restoring file systems.  An archive cannot be extracted or listed with
the `--incremental' (`-G') option specified unless it was created with
this option specified.  This option should only be used by a script,
not by the user, and is usually disregarded in favor of
`--listed-incremental=SNAPSHOT-FILE' (`-g SNAPSHOT-FILE'), which is
described below.

   `--incremental' (`-G') in conjunction with `--create' (`-c') causes
`tar' to write, at the beginning of the archive, an entry for each of
the directories that will be archived.  The entry for a directory
includes a list of all the files in the directory at the time the
archive was created and a flag for each file indicating whether or not
the file is going to be put in the archive.

   Note that this option causes `tar' to create a non-standard archive
that may not be readable by other versions of the `tar' program.

   `--incremental' (`-G') in conjunction with `--extract' (`--get',
`-x') causes `tar' to read the lists of directory contents previously
stored in the archive, *delete* files in the file system that did *not*
exist in their directories when the archive was created, and then
extract the files in the archive.

   This behavior is convenient when restoring a damaged file system from
a succession of incremental backups: it restores the entire state of
the file system to that which obtained when the backup was made.  If
`--incremental' (`-G') isn't specified, the file system will probably
fill up with files that shouldn't exist any more.

   `--incremental' (`-G') in conjunction with `--list' (`-t') causes
`tar' to print, for each directory in the archive, the list of files in
that directory at the time the archive was created.  This information
is put out in a format that is not easy for humans to read, but which
is unambiguous for a program: each file name is preceded by either a
`Y' if the file is present in the archive, an `N' if the file is not
included in the archive, or a `D' if the file is a directory (and is
included in the archive).  Each file name is terminated by a null
character.  The last file is followed by an additional null and a
newline to indicate the end of the data.


File: paxutils.info,  Node: listed-incremental,  Prev: incremental,  Up: incremental listed-incremental

Backing up with a snapshot list
-------------------------------

   `--listed-incremental=SNAPSHOT-FILE' (`-g SNAPSHOT-FILE') acts like
`--incremental' (`-G'), but when used in conjunction with `--create'
(`-c') will also cause `tar' to use the file SNAPSHOT-FILE, which
contains information about the state of the file system at the time of
the last backup, to decide which files to include in the archive being
created.  That file will then be updated by `tar'.  If the file FILE
does not exist when this option is specified, `tar' will create it, and
include all appropriate files in the archive.  However, if the created
archive is sent to the sink (by creating over `/dev/null'), the
snapshot file is neither created nor updated.

   The file FILE, which is archive independent, contains the date it
was last modified and a list of devices, inode numbers and directory
names.  `tar' will archive files with newer mod dates or inode change
times, and directories with an unchanged inode number and device but a
changed directory name.  The file is updated after the files to be
archived are determined, but before the new archive is actually created.

   Although it should be obvious that a device has a non-volatile
value, NFS devices have non-dependable values when an automounter gets
into the picture.  This leads to a great deal of spurious redumping in
incremental dumps, so it is somewhat useless to compare two NFS device
numbers over time.  So `tar' now considers all NFS devices as being
equal when it comes to comparing directories; this is fairly gross, but
there does not seem to be a better way to go.


File: paxutils.info,  Node: Backup levels,  Next: Backup parameters,  Prev: incremental listed-incremental,  Up: Backups

Levels of backups
=================

   An archive containing all the files in the file system is called a
"full backup" or "full dump".  You could ensure your data by creating a
full dump every day.  This strategy, however, would waste a substantial
amount of archive media and user time, as unchanged files are daily
re-archived.

   It is more efficient to do a full dump only occasionally.  To back up
files between full dumps, you can do an incremental dump.  A "level
one" dump archives all the files that have changed since the last full
dump.

   A typical dump strategy would be to perform a full dump once a week,
and a level one dump once a day.  This means some versions of files
will in fact be archived more than once, but this dump strategy makes
it possible to restore a file system to within one day of accuracy by
only extracting two archives--the last weekly (full) dump and the last
daily (level one) dump.  The only information lost would be in files
changed or created since the last daily backup.  (Doing dumps more than
once a day is usually not worth the trouble).

   `tar' comes with scripts you can use to do full and level-one dumps.
Using scripts (shell programs) to perform backups and restoration is a
convenient and reliable alternative to typing out file name lists and
`tar' commands by hand.

   Before you use these scripts, you need to edit the file
`backup-specs', which specifies parameters used by the backup scripts
and by the restore script.    *Note Script syntax::.  Once the backup
parameters are set, you can perform backups or restoration by running
the appropriate script.

   The name of the restore script is `restore'.    The names of the
level one and full backup scripts are, respectively, `level-1' and
`level-0'.  The `level-0' script also exists under the name `weekly',
and the `level-1' under the name `daily'--these additional names can be
changed according to your backup schedule.  *Note Scripted
restoration::, for more information on running the restoration script.
*Note Scripted backups::, for more information on running the backup
scripts.

   *Please note:* The backup scripts and the restoration scripts are
designed to be used together.  While it is possible to restore files by
hand from an archive which was created using a backup script, and to
create an archive by hand which could then be extracted using the
restore script, it is easier to use the scripts.   *Note incremental::,
and *Note listed-incremental::, before making such an attempt.

* Menu:

* Full dumps::                  Using `tar' to perform full dumps
* Incremental dumps::           Using `tar' to perform incremental dumps

